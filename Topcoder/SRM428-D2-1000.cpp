/*
notice that if we have n a's and m's then there's (n+m)!/n!m! let's name it f(n,m)
now we iterate through the string recureisvly, and if at position i
we can place a, then we will have f(n-1,m) choices
if this >= k, then we can place a here and continue
else we place z and recurse with f(n,m-1)   and k = k-f(n-1,m)
as we already skipped all strings that a-th in i-th position
we just need to watch for overflow while computing f(n,m)
which can be done with gcd
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

typedef long long ll;

class TheDictionary {
public:
	string find(int n, int m, int k);
};


ll gcd(ll a, ll b){
	return (!b) ? a : gcd(b, a%b);
}

bool prem(int n, vector<ll> den, int k){ // den n1!*n2!*n3! ( where n[i] is repesented as 2*3*4*..*n[i] )  
	vector<ll> num;
	for (int i = 2; i <= n; i++)	num.push_back(i); // make n! as 2*3*4*...*n
	for (auto &d : den){ // for each number in denominator find if it has gcd with numbers in numinator ( d has to be 1 after we finish this loop)
		for (int i = 0; i < num.size(); i++) { // find gcd for it with any number in numinator
			ll g = gcd(d, num[i]);
			num[i] /= g;
			d /= g;
		}
	}
	ll ret = 1;
	for (auto i : num){ // now just calcuate num!
		if (ret >= k) return 1;
		ret *= i;
	}
	if (ret >= k) return 1;
	return 0;
}

ll nprem(int n, vector<ll> den){ // den n1!*n2!*n3! ( where n[i] is repesented as 2*3*4*..*n[i] )  
	vector<ll> num;
	for (int i = 2; i <= n; i++)	num.push_back(i); // make n! as 2*3*4*...*n
	for (auto &d : den){ // for each number in denominator find if it has gcd with numbers in numinator ( d has to be 1 after we finish this loop)
		for (int i = 0; i < num.size(); i++) { // find gcd for it with any number in numinator
			ll g = gcd(d, num[i]);
			num[i] /= g;
			d /= g;
		}
	}
	ll ret = 1;
	for (auto i : num) // now just calcuate num!
		ret *= i;
	return ret;
}

vector<ll> get(vector<ll> den){
	vector<ll> dd;
	for (auto d : den){
		for (int i = 2; i <= d; i++)dd.push_back(i);
	}
	return dd;
}



string TheDictionary::find(int n, int m, int k) {
	if (n > 0 && prem(n + m - 1, get({ n - 1, m }), k))
		return "a" + TheDictionary::find(n - 1, m, k);
	if (m > 0 && prem(n + m - 1, get({ n, m - 1 }), k - nprem(n + m - 1, get({ n - 1, m }))))
		return "z" + TheDictionary::find(n, m - 1, k - nprem(n + m - 1, get({ n - 1, m })));
	return "";
}


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	TheDictionary *obj;
	string answer;
	obj = new TheDictionary();
	clock_t startTime = clock();
	answer = obj->find(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	}
	else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	}
	else if (hasAnswer) {
		cout << "Match :-)" << endl;
	}
	else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	int p0;
	int p1;
	int p2;
	string p3;

	{
		// ----- test 0 -----
		p0 = 10;
		p1 = 10;
		p2 = 1000000000;
		p3 = "";
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		p0 = 2;
		p1 = 2;
		p2 = 6;
		p3 = "zzaa";
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		p0 = 10;
		p1 = 10;
		p2 = 1000000000;
		p3 = "";
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		p0 = 7;
		p1 = 4;
		p2 = 47;
		p3 = "aaazazaazaz";
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	}
	else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
