
/*
	We can see uppbound is around 3000,000 because max value 999,999 give us 9^6*6 = 3188646
	so we can memorize for each vale minimum value of the cycle he will make
	
	So for each value start with it till you encounter a repeated elements, and memroize minimum value for all elemetns in this cycle

*/

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <bits/stdc++.h>
#include <unordered_set>
using namespace std;


class ExtendedHappyNumbers {
public:
	long long calcTheSum(int A, int B, int K);
};

typedef long long ll;


int dp[5000500];

ll po(int d, int n){
	ll ret = 1;
	for (int i = 0; i < n; i++)  ret *= ll(d);
	return ret;
}

int K;

int nxt(int nu){
	int ret = 0;
	while (nu){
		ret += po(nu % 10, K);
		nu /= 10;
	}
	return ret;
}



long long ExtendedHappyNumbers::calcTheSum(int A, int B, int _K) {
	ll ret = 0;
	K = _K;
	memset(dp, -1, sizeof(dp));
	unordered_set<int> inStack;
	stack<int> cur;
	for (int i = A; i <= B; i++){
		inStack.clear();
		cur = stack<int>();
		int t = i;
		while (true){
			if (dp[t] != -1 || inStack.find(t) != inStack.end()) break;
			inStack.insert(t);
			cur.push(t);
			t = nxt(t);
		}
		int mi = t;
		if (dp[t] == -1){
			while (cur.top() != t){
				mi = min(mi, cur.top());
				cur.pop();
			}
			dp[t] = mi;
			for (int i = nxt(t); i != t; i = nxt(i))
				dp[i] = mi;
		}	
		else
			mi = dp[t];
		while (!cur.empty()) mi = min(mi, cur.top()), dp[cur.top()] = mi, cur.pop();
		ret += mi;
	}
	return ret;
}

















// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, long long p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	ExtendedHappyNumbers *obj;
	long long answer;
	obj = new ExtendedHappyNumbers();
	clock_t startTime = clock();
	answer = obj->calcTheSum(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	long long p3;
	
	{
	// ----- test 0 -----
	p0 = 1;
	p1 = 5;
	p2 = 2;
	p3 = 14ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 10;
	p1 = 99;
	p2 = 1;
	p3 = 450ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 535;
	p1 = 538;
	p2 = 3;
	p3 = 820ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 100000;
	p1 = 400000;
	p2 = 6;
	p3 = 5169721292ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
