/*
the problem seems more related to topological sort
but how to build DAG to work on !

first of all if there's some char in part[i] in not consective positions then answer is IMP

now let's try to work with each character indivdualy
now we know all char's occur consectivly
so only 4 possible configurations for each char in each part[]
either all occurances's of this char is in left or middle or right or all of the string
if we have chars in middle then it has to be on only one part[i] and can't occur on left/right/all
otherwise now we can make a DAG like this
left -> all -> right

we cann maintain DSU while building the graph, if we created some cycle at anytime then answer is IMP

if at end we only have one forest, then there's unique answer
else we have many answers
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

#define all(v)           ((v).begin()), ((v).end())
#define sz size()
#define lp(i, n)         for(int i=0;i<(int)(n);++i)
#define lpi(i, j, n)     for(int i=(j);i<(int)(n);++i)
#define lpd(i, j, n)     for(int i=(j);i>=(int)(n);--i

class GroupedWord {
public:
	string restore(vector <string> parts);
};

int f[55][55];
int in[55];
int p[55], fo;

int par(int x){
	return (x == p[x]) ? x : p[x] = par(p[x]);
}

bool addEdge(int a, int b){
	int u = par(a), v = par(b);
	if (u == v) return 0;
	p[v] = u;
	f[a][b] = 1;
	in[b]++;
	fo--;
	return 1;
}

string GroupedWord::restore(vector <string> parts) {
	int n = parts.size();
	lp(i, n) p[i] = i;
	fo = n;
	lp(i, n) lp(j, n) f[i][j] = 0;
	lp(i, n) in[i] = 0;
	set<char> av;
	for (auto s : parts){
		set<char> un(s.begin(), s.end());
		for (auto c : un){
			av.insert(c);
			vector<int> po;
			for (int i = 0; i < s.size(); i++) if (s[i] == c)
				po.push_back(i);
			for (int i = 1; i < po.size(); i++) if (po[i] != po[i - 1] + 1) return "IMPOSSIBLE";
		}
	}
	for (auto ch : av){
		vector<int> l, m, r, al;
		lp(i, n){
			int cnt = count(all(parts[i]), ch);
			if (cnt == 0) continue;
			if (cnt == parts[i].size()) al.push_back(i);
			else if (parts[i][0] == ch) r.push_back(i);
			else if (parts[i].back() == ch) l.push_back(i);
			else m.push_back(i);
		}
		if (l.size() >1 || r.size() > 1 || m.size()>1) return "IMPOSSIBLE";
		if (!m.empty() && (l.size() > 0 || r.size() > 0 || al.size() > 0)) return "IMPOSSIBLE";
		if (m.size() == 1) continue;
		sort(all(al));
		lpi(i, 1, al.size()) {
			if (!addEdge(al[i - 1], al[i])) return "IMPOSSIBLE";
		}
		if (l.size() > 0){
			if (al.size() > 0){
				if (!addEdge(l[0], al[0])) return "IMPOSSIBLE";
			}
			else if (r.size() > 0){
				if (!addEdge(l[0], r[0])) return "IMPOSSIBLE";
			}
		}
		if (al.size() > 0){
			if (r.size() > 0){
				if (!addEdge(al.back(), r[0])) return "IMPOSSIBLE";
			}
		}
	}
	if (fo > 1) return "MANY";
	queue<int> q;
	for (int i = 0; i < n; i++) if (in[i] == 0) q.push(i);
	vector<int> r;
	// not handling multiple edges
	while (!q.empty()){
		int u = q.front();	 q.pop();
		r.push_back(u);
		lp(v, n) if (f[u][v]){
			in[v]--; // remove this edge
			if (in[v] == 0) q.push(v);
		}
	}
	string ret;
	for (int i : r) ret += parts[i];
	return ret;
}


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	GroupedWord *obj;
	string answer;
	obj = new GroupedWord();
	clock_t startTime = clock();
	answer = obj->restore(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	}
	else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	}
	else if (hasAnswer) {
		cout << "Match :-)" << endl;
	}
	else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	string p1;

	{
		// ----- test 0 -----
		string t0[] = { "ab", "bc", "ca" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		string t0[] = { "ab", "bba" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		string t0[] = { "te", "st" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = "stte";
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		string t0[] = { "te", "s", "t" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = "MANY";
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 4 -----
		string t0[] = { "orr", "rd", "woo", "www" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = "wwwwooorrrd";
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 5 -----
		string t0[] = { "abcb" };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = "IMPOSSIBLE";
		all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	}
	else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
