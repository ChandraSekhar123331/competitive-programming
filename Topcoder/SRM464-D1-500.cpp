/*
	first: notice that to get maximum side of minimum square it make sense to make all squares equal to this side, 
	as making them bigger can only make overlap and we don't get bigger number for minimum one.
	-now it's clear we can binary search this number 
	-now given a length l, is there's way to make squares without overlapping
	,this problem can be solved by 2-SAT, if any 2-centers(i,j) overlaps we add a caluse ~(i&&j)
	,meaning we can't use i and j at same time, ~(i&&j) == (~i || ~j)
	which make our CNF and what remains to use standard 2-SAT to check 
*/
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;


#define all(v)			((v).begin()), ((v).end())
#define sz(v)			((int)((v).size()))
#define clr(v, d)		memset(v, d, sizeof(v))
#define rep(i, v)		for(int i=0;i<sz(v);++i)
#define lp(i, n)		for(int i=0;i<(int)(n);++i)
#define lpi(i, j, n)	for(int i=(j);i<(int)(n);++i)
#define lpd(i, j, n)	for(int i=(j);i>=(int)(n);--i)
typedef long long ll;



int n, n2, m, ndfn;
vector< vector<int> > adjList, comps, dagList;
vector<int> inStack, lowLink, dfn, comp, assigned_val, cmp_root_node;
stack<int> stk;


// Switch between even odd: (0, 1), (2, 3)..
#define NOT(x)    (x < n2 ? x+n2:x-n2 )

void tarjan(int node) {
	lowLink[node] = dfn[node] = ndfn++, inStack[node] = 1;
	stk.push(node);

	rep(i, adjList[node]) {
		int ch = adjList[node][i];
		if (dfn[ch] == -1) {
			tarjan(ch);
			lowLink[node] = min(lowLink[node], lowLink[ch]);
		}
		else if (inStack[ch])
			lowLink[node] = min(lowLink[node], dfn[ch]);
	}

	if (lowLink[node] == dfn[node]) {
		comps.push_back(vector<int>());
		int x = -1;
		while (x != node) {
			x = stk.top(), stk.pop(), inStack[x] = 0;
			comps.back().push_back(x);
			comp[x] = sz(comps) - 1;
		}
		cmp_root_node[comp[node]] = node;		// ***
	}
}

// acceptable values: (0, 1), (1, 0), (1, 1)
void add_or(int a, int b)
{
	adjList[NOT(a)].push_back(b);
	adjList[NOT(b)].push_back(a);
}

vector<int> xa, ya;

void scc(int l) {
	inStack.clear();		inStack.resize(n);
	lowLink.clear();		lowLink.resize(n);
	assigned_val.clear();	assigned_val.resize(n);
	cmp_root_node.clear();		cmp_root_node.resize(n);
	dfn.clear();			dfn.resize(n, -1);
	ndfn = 0;

	comp.clear(), comp.resize(n);
	comps.clear();
	adjList.clear();
	adjList.resize(n);

	for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++)
		if (max(abs(xa[i] - xa[j]), abs(ya[i] - ya[j])) < l)
			add_or(NOT(i), NOT(j));

	lp(i, n) if (dfn[i] == -1)
		tarjan(i);
}

bool is_solvable(int l)
{
	scc(l);
	for (int i = 0; i < n; i++)
		if (comp[i] == comp[NOT(i)])
			return false;
	return true;
}

class ColorfulDecoration {
public:
	int getMaximum(vector <int> xa, vector <int> ya, vector <int> xb, vector <int> yb);
};

int ColorfulDecoration::getMaximum(vector <int> _xa, vector <int> _ya, vector <int> xb, vector <int> yb) {
	xa = _xa, ya = _ya;
	n2 = xa.size();
	n = n2 * 2;
	xa.insert(xa.end(), xb.begin(), xb.end());
	ya.insert(ya.end(), yb.begin(), yb.end());
	int l = 0, r = 2147483647;
	while (l + 1 < r){
		int mid = l + (r - l) / 2;
		if (is_solvable(mid)) l = mid;
		else r = mid;
	}
	return l;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, vector <int> p3, bool hasAnswer, int p4) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}";
	cout << "]" << endl;
	ColorfulDecoration *obj;
	int answer;
	obj = new ColorfulDecoration();
	clock_t startTime = clock();
	answer = obj->getMaximum(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	}
	else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	}
	else if (hasAnswer) {
		cout << "Match :-)" << endl;
	}
	else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <int> p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	int p4;

	{
		// ----- test 0 -----
		int t0[] = { 10, 0, 7 };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = { 0, 19, 6 };
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		int t2[] = { 20, 10, 25 };
		p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
		int t3[] = { 20, 35, 25 };
		p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
		p4 = 19;
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		int t0[] = { 464, 20 };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = { 464, 10 };
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		int t2[] = { 464, 3 };
		p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
		int t3[] = { 464, 16 };
		p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
		p4 = 461;
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		int t0[] = { 0, 0, 1, 1 };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = { 0, 0, 1, 1 };
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		int t2[] = { 1, 1, 0, 0 };
		p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
		int t3[] = { 1, 1, 0, 0 };
		p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
		p4 = 0;
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		int t0[] = { 0, 3, 0, 5, 6 };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = { 1, 6, 0, 8, 5 };
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		int t2[] = { 6, 1, 7, 4, 7 };
		p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
		int t3[] = { 5, 9, 2, 8, 9 };
		p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
		p4 = 3;
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
	}

	{
		// ----- test 4 -----
		int t0[] = { 1000000000, 0 };
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = { 0, 1000000000 };
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		int t2[] = { 0, 1000000000 };
		p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
		int t3[] = { 0, 1000000000 };
		p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
		p4 = 1000000000;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	}
	else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
