/*
	-Solutoin of grundy with dp of bitmasking get TLE

	-This game can be modeled as a nim game 
	Where each pile size is the ditance from a black cell to another black one ( or end of tiles )
	As you can pick one black cell and go left as long as adjacent to left is white

	We can ignore moving right, because you can just play it from right one moving left
*/


#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <bits/stdc++.h>
#include <unordered_set>
#include <unordered_map>
using namespace std;


class CatAndRabbit {
public:
	string getWinner(string tiles);
};

typedef	long long ll;

int mex(unordered_set<int> &hashtable){
	int val = 0;
	while (hashtable.find(val) != hashtable.end()) val++;
	return val;
}

int n;
unordered_map<ll, int> dp;

int grundy(ll mask){
	if (dp.find(mask) != dp.end()) return dp[mask];
	unordered_set<int> mo;
	for (int i = 0; i < n; i++) if (mask >> i & 1){
		ll tmask = mask;
		for (int j = i + 1; j < n; j++){
			if (tmask >> j & 1) break;
			tmask |= (1LL << j);
			mo.insert(grundy(tmask));
		}
		tmask = mask;
		for (int j = i - 1; j >= 0; j--){
			if (tmask >> j & 1) break;
			tmask |= (1LL << j);
			mo.insert(grundy(tmask));
		}
	}
	return dp[mask] = mex(mo);
}

string CatAndRabbit::getWinner(string tiles) {
	n = tiles.size() + 2;
	int xorSum = 0;
	tiles.push_back('#');
	tiles = '#' + tiles;
	for (int i = 0; i < n; i++) if (tiles[i] == '#') {
		for (int j = i + 1; j < (n - !i); j++)
			if (tiles[j] == '#'){
				xorSum ^= j - i - 1;
				break;
			}
	}
	return xorSum ? "Cat" : "Rabbit";
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	CatAndRabbit *obj;
	string answer;
	obj = new CatAndRabbit();
	clock_t startTime = clock();
	answer = obj->getWinner(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	}
	else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	}
	else if (hasAnswer) {
		cout << "Match :-)" << endl;
	}
	else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	string p0;
	string p1;

	{
		// ----- test 0 -----
		p0 = "#..";
		p1 = "Cat";
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		p0 = ".#.";
		p1 = "Rabbit";
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		p0 = "###";
		p1 = "Rabbit";
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		p0 = "#..##.#";
		p1 = "Cat";
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 4 -----
		p0 = "...";
		p1 = "Rabbit";
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 5 -----
		p0 = "###...####....###...####....";
		p1 = "Rabbit";
		all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 6 -----
		p0 = ".#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.";
		p1 = "Rabbit";
		all_right = KawigiEdit_RunTest(6, p0, true, p1) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	}
	else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
